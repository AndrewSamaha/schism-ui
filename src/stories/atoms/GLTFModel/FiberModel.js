/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/


import React, { useRef, useState, useMemo } from 'react'
import { useFrame } from '@react-three/fiber';
import { useGLTF } from '@react-three/drei';
import get from 'lodash/get';
import compact from 'lodash/compact';

// entity dispatch events
import { SELECT_ENTITY, HOVER_ENTITY_START, HOVER_ENTITY_STOP } from '../../../reducers/entityReducer';

export function FiberModel(props) {
  const { entity, entityReducer, action, mutations, fiberModelPath } = props;
  const { materialMap, rotation }= entity;
  const { position } = props;
  // const { color, position, rotation, id, scale } = entity;
  const { entityState, entityDispatch } = entityReducer;

  const ref = useRef();
  const [hovered, hover] = useState(false);
  const { nodes, materials } = useGLTF(fiberModelPath);

  useFrame((state, delta) => {
    if (entity.tic) entity.tic(ref, delta, entityReducer, mutations);
  });

  const meshes = useMemo(() => compact(Object.entries(nodes).map(([key, value]) => {
    const geometry = get(nodes, `${key}.geometry`, null);
    const material = materials[`${materialMap(key)}`]; 
    if (!geometry) return null;
    if (!key) return null;
    
    return (<mesh key={key} geometry={geometry} material={material} material-color={hovered ? 'white' : props.color}/>);})),
    [nodes, hovered]);

  return (
      <group {...props} position={position} key={entity.id} dispose={null}
        ref={ref}
        rotation={rotation}
        onClick={(event) => {
          if (action) return;
          if (entityState.selectedUnits.length && entityState.selectedUnits[0].id === entity.id) return;
          entityDispatch({ 
            type: SELECT_ENTITY,
            payload: [entity] 
          }) 
        }}
        onPointerOver={(event) => {
          if (action) return;
          hover(true);
          entityDispatch({
            type: HOVER_ENTITY_START,
            payload: entity
          });
        }}
        onPointerOut={(event) => {
          if (action) return;
          hover(false)
          entityDispatch({
            type: HOVER_ENTITY_STOP,
            payload: entity
          });
        }}
        >
          {meshes}
        </group>
  )
}
